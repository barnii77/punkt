#include "punkt/dot.hpp"
#include "punkt/dot_constants.hpp"
#include "punkt/utils/int_types.hpp"
#include <gtest/gtest.h>
#include <string>
#include <vector>
#include <string_view>
#include <iostream>

using namespace punkt;

// extern ssize_t punkt::BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION;

TEST(preprocessing, OptimalHorizontalOrdering) {
    // This DOT source defines our layered DAG.
    // Non-ghost nodes are: Rank 0: A, B, C; Rank 1: D, E; Rank 2: F, G, H; Rank 3: I, J.
    // Edges are chosen to trigger ghost node insertion:
    //   - A->F jumps from rank 0 to 2, so a ghost node is inserted in rank 1.
    //   - B->I jumps from rank 0 to 3, so two ghost nodes are inserted (rank 1 then rank 2).
    //   - F->G is a same-rank edge (rank 2 to 2) so a ghost is inserted at rank 3.
    const std::string dot_source = R"(
        digraph OptimalTest {
            // Declare nodes (order in source is not necessarily preserved, but ranks will be computed)
            A; B; C;
            D; E; F;
            G; H; I;
            J;
            // Edges:
            A -> D;
            B -> D;
            C -> E;
            A -> F;
            D -> G;
            E -> G;
            D -> H;
            B -> I;
            F -> I;
            G -> J;
            H -> J;
            F -> G;
        }
    )";

    // Parse the graph. Let preprocess() compute node ranks and also perform ghost insertion.
    Digraph dg{dot_source};
    render::glyph::GlyphLoader glyph_loader;

    // Change some settings because the orderer actually does not converge to the complete optimal solution (though the
    // solution it finds is very close to optimal). So why leave the actual settings in? Empirically, a combination of
    // barycenter followed by my bubble reordering seems to usually find better solutions than bubble reordering alone
    // on large graphs because barycenter is more powerful at performing global reorderings and can help break out of
    // local optima.
    const ssize_t normal_barycenter_iters_setting = BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION;
    BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION = 0;

    dg.preprocess(glyph_loader);

    BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION = normal_barycenter_iters_setting;

    // Expected optimal ordering per rank (as deduced above):
    // Note: Ghost node names are generated by newGhostNode as "@" followed by a counter.
    const std::vector<std::vector<std::string_view> > expected_orderings = {
        {"B", "A", "C"}, // Rank 0
        {"@0", "D", "F", "E"}, // Rank 1 (ghosts from A->F and B->I)
        {"I", "H", "G"}, // Rank 2 (ghost from B->I)
        {"J"}, // Rank 3 (ghost from F->G)
    };

    std::cout << "OptimalHorizontalOrdering Rank Visualization:" << std::endl;
    for (size_t rank = 0; const auto &ordering: dg.m_per_rank_orderings) {
        std::cout << "  Rank " << rank << ": ";
        for (const auto &node: ordering) {
            std::cout << node << " ";
        }
        std::cout << std::endl;
        rank++;
    }

    // Check that computed orderings match expected orderings.
    ASSERT_EQ(dg.m_per_rank_orderings.size(), expected_orderings.size())
        << "Rank ordering vector size mismatch.";

    for (size_t rank = 0; rank < expected_orderings.size(); rank++) {
        const auto &expected = expected_orderings[rank];
        const auto &actual = dg.m_per_rank_orderings[rank];
        ASSERT_EQ(actual.size(), expected.size()) << "Rank " << rank << " size mismatch.";
        for (size_t i = 0; i < expected.size(); i++) {
            EXPECT_EQ(actual[i], expected[i])
                  << "Mismatch at rank " << rank << ", index " << i
                  << " (expected " << expected[i] << ", got " << actual[i] << ")";
        }
    }
}

TEST(preprocessing, WeightWorks) {
    const std::string dot_source = R"(
        digraph G {
            punktxopt=false;
            A; B; C;
            D; E; F;
            G; H; I;
            J;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            A -> D;
            B -> D;
            C -> E;
            A -> F;
            D -> G [weight=1000];
            E -> G;
            D -> H;
            B -> I [constraint=false];
            F -> I;
            G -> J;
            H -> J;
            F -> G;
        }
    )";

    // Parse the graph. Let preprocess() compute node ranks and also perform ghost insertion.
    Digraph dg{dot_source};
    render::glyph::GlyphLoader glyph_loader;

    // Change some settings because the orderer actually does not converge to the complete optimal solution (though the
    // solution it finds is very close to optimal). So why leave the actual settings in? Empirically, a combination of
    // barycenter followed by my bubble reordering seems to usually find better solutions than bubble reordering alone
    // on large graphs because barycenter is more powerful at performing global reorderings and can help break out of
    // local optima.
    const ssize_t normal_barycenter_iters_setting = BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION;
    BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION = 0;

    dg.preprocess(glyph_loader);

    BARYCENTER_ORDERING_MAX_ITERS_PER_DIRECTION = normal_barycenter_iters_setting;

    // Expected optimal ordering per rank (as deduced above):
    // Note: Ghost node names are generated by newGhostNode as "@" followed by a counter.
    const std::vector<std::vector<std::string_view> > expected_orderings = {
        {"B", "A", "C"},
        {"@0", "D", "F", "E"},
        {"H", "G", "I"},
        {"J"},
    };

    std::cout << "WeightWorks Rank Visualization:" << std::endl;
    for (size_t rank = 0; const auto &ordering: dg.m_per_rank_orderings) {
        std::cout << "  Rank " << rank << ": ";
        for (const auto &node: ordering) {
            std::cout << node << " ";
        }
        std::cout << std::endl;
        rank++;
    }

    // Check that computed orderings match expected orderings.
    ASSERT_EQ(dg.m_per_rank_orderings.size(), expected_orderings.size())
        << "Rank ordering vector size mismatch.";

    for (size_t rank = 0; rank < expected_orderings.size(); rank++) {
        const auto &expected = expected_orderings[rank];
        const auto &actual = dg.m_per_rank_orderings[rank];
        ASSERT_EQ(actual.size(), expected.size()) << "Rank " << rank << " size mismatch.";
        for (size_t i = 0; i < expected.size(); i++) {
            EXPECT_EQ(actual[i], expected[i])
                  << "Mismatch at rank " << rank << ", index " << i
                  << " (expected " << expected[i] << ", got " << actual[i] << ")";
        }
    }
}
